module gameCU (
    input clk,        // clock
    input rst,        // reset
    input buttons[3], // button input, 0-2 left to right
    input reg48[16],  // branching reg
    input reg4B[16],
    input timerTick,  // 1 when timer should update (edge detector)
    input debugIn[16],// debug inputs to trigger game states
    
    output alufn[6],  // define ALU op
    output bsel,      // 0 for OP, 1 for OPC
    output c[16],     // constant for OPC
    
    output ra[7],     // read address a
    output rb[7],     // read address b
    output rc[7],     // write address c
    output we,        // write enable
    output sr,     // update board gameState regs
    
    output ioState[4],// 0: -, 1: blank, 2: win, 3: lose, 4: low time
    output debugSeg[16], // 7seg debug output
    output debugLed[16]  // led debug output
  ) {
  
  // TODOS
  // Add little time left (Timer)
  // Reduce states from branching (due to boostrapped reg48)
  // Add SHOOT_AMMO_CHECKing
  // bsel and c can be simplified into one control signal
  
  .clk(clk) {
    
    //Edge Detector
    edge_detector slow_clock_edge_detector(#RISE(1), #FALL(0));
    
    fsm gameState(#INIT(IDLE)) = {
      IDLE, // await start game, initialise board
      INIT_TIMER, // start timer
      PLAY, // await player action
      
      TIMER_CHECK, // check if game ended, decrease otherwise
      TIMER_BRANCH,
      TIMER_DECREASE,
      
      LEFT_CHECK, // check left bounds, move player
      LEFT_BRANCH,
      LEFT_REPOS,
      
      RIGHT_CHECK, // check right bounds, move player
      RIGHT_BRANCH,
      RIGHT_REPOS,
      
      SHOOT_AMMO_CHECK, // check ammo, SHOOT_AMMO_CHECK, remove bomb, decrement ammo
      SHOOT_AMMO_BRANCH,
      DECREMENT_AMMO,
      SHOOT_INIT_CHECK_POS,
      BOMB_CHECK_INCREMENT,
      SHOOT_CHECK_HAS_BOMB,
      SHOOT_BOMB_BRANCH,
      DELETE_BOMB,
      
      RESET_BOMBS,
      COUNT_BOMBS, // calculate bombs
      CHECK_POSITION_FOR_BOMB,
      INCREMENT_POS,
      
      // Lives
      UPDATE_LIVES,
      CHECK_PLAYER_LIVES,
      CHECK_ALIVE,
      ALIVE_BRANCH, //branch to check if player is alive
      
      // Board Update
      UPDATE_BOARD,
      UPDATE_BOARD_BRANCH,
      // READ_LEVELS,
      
      WIN, LOSE,
      RESET,
      LINES_CHECK, // Check if the lines are 0
      DECREMENT_ROW,
      UPDATE_ROWS, // TODO : Need rom selector
      
      //DEBUG With Slow Clock
      IDLE_DEBUG,
      LEFT_CHECK_DEBUG,
      SHOOT_AMMO_CHECK_DEBUG,
      RIGHT_CHECK_DEBUG,
      TIMER_CHECK_DEBUG
    };
    
    .rst(rst) {
      dff pos[8](#INIT(8h03)), lives[8](#INIT(8h03));
      counter slow_timer(#SIZE(1),#DIV(26));  // slow clock
    }
    
  }
  
  always {
    // default control signals
    alufn = 6b0; bsel = 0; c = 16h0000;
    ra = 7h0; rb = 7h0; rc = 7h0; we = 0; sr = 0;
    ioState = 4h0;
    debugSeg = 16h0000;
    
    //edge detectors
    slow_clock_edge_detector.in = slow_timer.value; // Put counter through edge detector
    
    if(rst) {
      gameState.d = gameState.IDLE;
    }
    
    case(gameState.q) {
      gameState.IDLE:
        if (buttons[0] || buttons[1] || buttons[2]) {
          // shift down by 1 row, ADDC: R50 += 0
          alufn = 6b000000; bsel = 1; c = 16h0000;
          ra = 7h50; rb = 7h0; rc = 7h50; we = 1; sr = 1;
          debugSeg = 16h0001;
          gameState.d = gameState.IDLE_DEBUG;
        }       
      
      gameState.IDLE_DEBUG:
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.INIT_TIMER;
        }
      
      gameState.INIT_TIMER:
        // ADDC: timer = 0+30
        alufn = 6b000000; bsel = 1; c = 16h001E;
        ra = 7h50; rb = 7h0; rc = 7h4A; we = 1; sr = 0;
        
        debugSeg = 16h0002;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.PLAY;
        }
      
      gameState.PLAY:
        debugSeg = 16h0003;
        
        if (buttons[0]) {
          gameState.d = gameState.LEFT_CHECK_DEBUG;
        }
        else if (buttons[1]) {
          gameState.d = gameState.SHOOT_AMMO_CHECK_DEBUG;
        }
        else if (buttons[2]) {
          gameState.d = gameState.RIGHT_CHECK_DEBUG;
        }
        // else if (timerTick) {
        //   gameState.d = gameState.TIMER_CHECK_DEBUG;
        // }
      
      gameState.LEFT_CHECK_DEBUG:
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.LEFT_CHECK;
        }
      
      gameState.SHOOT_AMMO_CHECK_DEBUG:
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.SHOOT_AMMO_CHECK;
        }
      
      gameState.RIGHT_CHECK_DEBUG:
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.RIGHT_CHECK;
        }
      
      gameState.TIMER_CHECK_DEBUG:
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.TIMER_CHECK;
        }
      
      /// ********* TIMER ********** ///
      gameState.TIMER_CHECK:
        // CMPEQ: time == 0
        alufn = b100001; bsel = 0; c = 16b0;
        ra = 7h4A; rb = 7h50; rc = 7h48; we = 1; sr = 0;

        debugSeg = 16h0010;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.TIMER_BRANCH;
        }
      
      gameState.TIMER_BRANCH:
        // LOSE if time == 0, TIMER_DECREASE otherwise
        debugSeg = 16h0011;
        if (slow_clock_edge_detector.out == 1){
          if (reg48 || (debugIn[0] && debugIn[1])) {
            gameState.d = gameState.LOSE;
          } else {
            gameState.d = gameState.TIMER_DECREASE;
          }
        }
      
      gameState.TIMER_DECREASE:
        // SUB: decrease timer by 1
        alufn = b000001; bsel = 0; c = 16b0;
        ra = 7h4A; rb = 7h51; rc = 7h4A; we = 1; sr = 0;
        
        debugSeg = 16h0012;
        gameState.d = gameState.PLAY;
      
      
      /// ********* MOVE PLAYER ********** ///
      gameState.LEFT_CHECK:
        // CMPLT: player pos < 0
        alufn = b100011; bsel = 0; c = 16b0;
        ra = 7h56; rb = 7h50; rc = 7h48; we = 1; sr = 0;
        
        debugSeg = 16h0020;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.LEFT_BRANCH;
        }
      
      gameState.LEFT_BRANCH:
        // PLAY if pos < 0, LEFT_REPOS otherwise
        debugSeg = 16h0021;
        if (slow_clock_edge_detector.out == 1){
          if (reg48 || (debugIn[0] && debugIn[4])) {
            gameState.d = gameState.PLAY;
          } else {
            gameState.d = gameState.LEFT_REPOS;
          }
        }
      
      gameState.LEFT_REPOS:
        // SUB: move player left
        alufn = b000001; bsel = 0; c = 16b0;
        ra = 7h56; rb = 7h51; rc = 7h56; we = 1; sr = 0;
        
        debugSeg = 16h0022;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.RESET_BOMBS;
        }
      
      gameState.RIGHT_CHECK:
        // CMPLEC: player pos < 7
        alufn = b100011; bsel = 1; c = 16h0007;
        ra = 7h56; rb = 7h00; rc = 7h48; we = 1; sr = 0;
        
        debugSeg = 16h0023;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.RIGHT_BRANCH;
        }
      
      gameState.RIGHT_BRANCH:
        // RIGHT_REPOS if pos < 7, PLAY otherwise
        debugSeg = 16h0024;
        if (slow_clock_edge_detector.out == 1){
          if (reg48 || (debugIn[0] && debugIn[5])) {
            gameState.d = gameState.RIGHT_REPOS;
          } else {
            gameState.d = gameState.PLAY;
          }
        }
      
      gameState.RIGHT_REPOS:
        // ADD: move player right
        alufn = b000000; bsel = 0; c = 16b0;
        ra = 7h56; rb = 7h51; rc = 7h56; we = 1; sr = 0;
        
        debugSeg = 16h0025;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.RESET_BOMBS;
        }
      
      gameState.SHOOT_AMMO_CHECK: //TODO : Not done yet. Might need to decrease ammo counter
        // CMPLE
        alufn = b100101; bsel = 1; c = 0;
        ra = 7h49; rb = 7h00; rc = 7h48; we = 1; sr = 0;
        
        debugSeg = 16h0026;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.SHOOT_AMMO_BRANCH;
        }
      
      gameState.SHOOT_AMMO_BRANCH:
        debugSeg = 16h0027;
        if ((reg48) && (slow_clock_edge_detector.out == 1)){
          gameState.d = gameState.RESET_BOMBS;
        } else {
          // SUB
          alufn = b000001; bsel = 1; c = 1;
          ra = 7h49; rb = 7h00; rc = 7h49; we = 1; sr = 0;
          if (slow_clock_edge_detector.out == 1){
            gameState.d = gameState.SHOOT_INIT_CHECK_POS;
          }
        }
      
      gameState.SHOOT_INIT_CHECK_POS:
        //ADD
        alufn = b100000; bsel = 0; c = 0;
        ra = 7h56; rb = 7h00; rc = 7h4B;

        debugSeg = 16h0028;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.SHOOT_CHECK_HAS_BOMB;
        }
      
      gameState.SHOOT_CHECK_HAS_BOMB:
        //CMPEQ: check position == 0
        alufn = b100001; bsel = 1; c = 1;
        ra = reg4B; rb = 7h00; rc = 7h48;

        debugSeg = 16h0029;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.SHOOT_BOMB_BRANCH;
        }
      
      gameState.SHOOT_BOMB_BRANCH:
        // DELETE_BOMB if check position == 0; BOMB_CHECK_INCREMENT otherwise
        
        debugSeg = 16h0030;

        if ((reg48) && (slow_clock_edge_detector.out == 1)){
          gameState.d = gameState.DELETE_BOMB;
        } else {
          if (slow_clock_edge_detector.out == 1){
            gameState.d = gameState.BOMB_CHECK_INCREMENT;
          }
        }
      
      gameState.BOMB_CHECK_INCREMENT:
        //ADD
        alufn = b100000; bsel = 1; c = 3b100;
        ra = reg4B; rb = 7h00; rc = 7h4B;

        debugSeg = 16h0031;
        if ((reg4B < 7h72) && (slow_clock_edge_detector.out == 1)){
          gameState.d = gameState.SHOOT_BOMB_BRANCH;
        } else {
          if (slow_clock_edge_detector.out == 1){
            gameState.d = gameState.RESET_BOMBS;
          }
        }
      
      gameState.DELETE_BOMB:
        //SUB
        alufn = b000001; bsel = 1; c = 1;
        ra = reg4B; rb = 7h00; rc = 7h4B;

        debugSeg = 16h0032;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.RESET_BOMBS;
        }
      
      
      /// ***** COUNT BOMBS ***** ///
      gameState.RESET_BOMBS:
        // 'A' boolean operation
        alufn = b010011; bsel = 1; c = 0;
        ra = 7h50; rb = 7h00; rc = 7h48; we = 1; sr = 0;
        
        debugSeg = 16h0033;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.COUNT_BOMBS;
        }
      
      gameState.COUNT_BOMBS:
        //CMPEQ
        alufn = b100001; bsel = 1; c = 1;
        ra = 7h00; rb = 7h00; rc = 7h48; we = 0; sr = 0;
        
        debugSeg = 16h0034;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.CHECK_POSITION_FOR_BOMB;
        }

      gameState.CHECK_POSITION_FOR_BOMB:
        debugSeg = 16h0035;
        if (reg48) {
          //ADD
          alufn = b000000; bsel = 1; c = 1;
          ra = 7h49; rb = 7h00; rc = 7h49; we = 1; sr = 0;
        } else {
            if (slow_clock_edge_detector.out == 1){
              gameState.d = gameState.INCREMENT_POS;
            }
        }
      
      gameState.INCREMENT_POS:
        debugSeg = 16h0036;
        if (reg4B < 7h08){ 
          //ADD
          alufn = b000000; bsel = 1; c = 1;
          ra = reg4B; rb = 7h00; rc = 7h4B; we = 1; sr = 0;
          if (slow_clock_edge_detector.out == 1){
            gameState.d = gameState.CHECK_POSITION_FOR_BOMB;
          }
        } else {
            if (slow_clock_edge_detector.out == 1){
              gameState.d = gameState.UPDATE_LIVES;
            }
        }

        
      /// ***** UPDATE LIVES ***** ///
      gameState.UPDATE_LIVES:
        // SUB: lives_left -= bomb_count
        alufn = b000001; bsel = 0; c = 0;
        ra = 7h54; rb = 7h49; rc = 7h54; we = 1; sr = 0;
        
        debugSeg = 16h0050;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.CHECK_PLAYER_LIVES;
        }
            
      gameState.CHECK_PLAYER_LIVES:
        // CMPLT: lives_left < 0
        alufn = b100011; bsel = 0; c = 0;
        ra = 7h54; rb = 7h50; rc = 7h48; we = 1; sr = 0;
        
        debugSeg = 16h0051;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.ALIVE_BRANCH;
        }
        
      gameState.ALIVE_BRANCH:
        // LOSE if player_life < 0, UPDATE_BOARD otherwise
        debugSeg = 16h0052;
        if (slow_clock_edge_detector.out == 1){
          if (reg48 || (debugIn[0] && debugIn[2])) {
            gameState.d = gameState.LOSE;
          } else {
            gameState.d = gameState.UPDATE_BOARD;
          }
        }
            
            
      /// ********* BOARD UPDATE ********** ///
      // Check whether game ends before updating the board
      gameState.UPDATE_BOARD:
        // CMPEQ: lines_left == 0
        alufn = b100001; bsel = 0; c = 16b0;
        ra = 7h53; rb = 7h50; rc = 7h48; we = 1; sr = 0;
        
        debugSeg = 16h0060;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.UPDATE_BOARD_BRANCH;
        }
        
      // Check if game is over or the rows is needed to be moved down
      gameState.UPDATE_BOARD_BRANCH:
        // lines_left == 0 win; update rows otherwise
        debugSeg = 16h0061;
        if (slow_clock_edge_detector.out == 1){
          if (reg48 || (debugIn[0] && debugIn[3])) {
            gameState.d = gameState.WIN;
          } else {
            gameState.d = gameState.UPDATE_ROWS;
          }
        }
            
      gameState.UPDATE_ROWS:
        // shift down by 1 row, ADDC: R50 += 0
        alufn = 6b000000; bsel = 1; c = 16h0000;
        ra = 7h50; rb = 7h0; rc = 7h50; we = 1; sr = 1;
        
        debugSeg = 16h0062;
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.DECREMENT_ROW;
        }
            
      // Read levels from ROM, may not be needed if implemented in regfile (sr=1)
      // TODO: Not too sure about this. need to check with @ruien
      // gameState.READ_LEVELS:
        // LD Reg[0x00 : 0x07] �?
        // Mem[Reg[0x56] : Reg[0x56] + 2 x 8]
        // alufn = b000000; bsel = 1; c = 1;
        // ra = addr of rom_sel
        // c = 1; we = 1; sr = 0;
        // gameState.d = gameState.DECREMENT_ROW;
        
        // LD Reg[0x00 : 0x07] �?
        // Mem[Reg[0x56] : Reg[0x56] + 2 x 8]
        // alufn = b000000; bsel = 1; c = 1;
        // ra = addr of rom_sel
        // c = 1; we = 1; sr = 0;
        // gameState.d = gameState.DECREMENT_ROW;
            
      // State to move the rows down
      gameState.DECREMENT_ROW:
        // SUB : lines_left = lines_left - 1
        debugSeg = 16h0063;
        alufn = b000001; bsel = 0; c = 16b0;
        ra = 7h53; rb = 7h51; rc = 7h53; we = 1; sr = 0;
        
        if (slow_clock_edge_detector.out == 1){
          gameState.d = gameState.PLAY; // Game state to wait for input from player
        }
        
      /// ********* END GAME ********** ///
      gameState.WIN:
        ioState = 4h2;
        if (buttons[0] || buttons[1] || buttons[2]) {
          gameState.d = gameState.IDLE;
        }
        debugSeg = 16h0070;
        
      gameState.LOSE:
        ioState = 4h3;
        if (buttons[0] || buttons[1] || buttons[2]) {
          gameState.d = gameState.IDLE;
        }
        debugSeg = 16h0071;
        
      } // end fsm
      
      debugLed[7:0] = 8h03;
      debugLed[15:8] = 8h03;
    }
  }